/**
 * Raspberry Pi java http server
 * v1.0
 * HttpReader Class
 * Http Protocol Reader for Http Server
 * http プロトコルに対応した Http Sever側の受信処理を行います。
 */
package http_pi;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Hashtable;

/**
 * @author nishi
 *
 */
public class HttpReader {
	public String req;
	public String host;
	public String content_type;
	public Boolean multipart_f=false;
	public String boundary;
	public String boundary1;
	public String boundary2;
	public String method;
	public String filename;
	public String version;
	public String p_data;
	
	public Hashtable<String,String> http_hd;
	public Hashtable<String,String> req_line;

	public boolean dump_f=false;
	private int ph;

	//private HttpReaderBuff data_bf;
	
	public HttpReader(){
		
	}
	public void read(taskTable tskt,InputStream in){
		req="";
		host="";
		content_type="";
		multipart_f=false;
		boundary="";
		boundary1="";
		boundary2="";
		method="";
		filename="";
		version="";
		p_data="";
		req_line = new Hashtable<String,String>();
		http_hd = new Hashtable<String,String>();
		//data_bf = new HttpReaderBuff();

		//dump_f=true;
		if(dump_f==true){
			// client からの http 受信データ のダンプ出力を行います。デバッグに使用できます。
			// HTTP プロトコルのデータの解析に使用できます。
			dump_din(in);
		}
		else{
			read_din(tskt,in);
		}
	}
	/*
	 * dump_din()
	 * ダンプ表示 for debug
	 */
	private void dump_din(InputStream in){
		HttpDataInputStream din_r = new HttpDataInputStream(in);
		try{
			String in_s;
			String p_line="";
			int n=0;
			req = din_r.readline();
			System.out.println("HttpReader::dump_din() :#1 recve socket stream="+req);
			while((in_s=din_r.readline()).length() > 0){
				System.out.println(in_s);
			}
			while (din_r.ready() == true && n < 1000){
				p_line=din_r.readline();
				System.out.println("HttpReader::dump_din() :#2 p_line="+p_line);
				n++;
			}
		}
		catch(IOException e){
			System.out.println("HttpReader::read_din() :#90 error ="+e);
		}
	}
	/**
	 * read_din()
	 * read data through DataInputStream
	 */
	private void read_din(taskTable tskt,InputStream in){
		String in_s;
		String s;
		String[] spl_d;
		String upload_parm_name="";
		HttpDataInputStream din_r = new HttpDataInputStream(in);
		try{
			// get request lines
			req = din_r.readline();
			System.out.println("HttpReader::read_din() :#1 recve socket stream="+req);
			http_hd.put("req", req);
			spl_d = req.split(" ");
			if(spl_d.length >= 1){
				method =spl_d[0];}
			if(spl_d.length >= 2){
				filename = spl_d[1];}
			if(spl_d.length >= 3){
				version = spl_d[2];}
			req_line.put("method", method);
			req_line.put("filename", filename);
			req_line.put("version", version);

			// get header lines
			while((in_s=din_r.readline()).length() > 0){
				System.out.println("HttpReader::read_din() :#2 in_s="+in_s);
				int pos= in_s.indexOf(":");
				if(pos > 0){
					String p_name=in_s.substring(0, pos+1);
					String p_val="";
					if(in_s.length() > pos+2){
						p_val=in_s.substring(pos+2);
					}
					http_hd.put(p_name, p_val);
					//System.out.println("HttpReader::read_din() :#3 p_name="+p_name+",p_val="+p_val);
				}
				// Post 
				// Content-Type: application/x-www-form-urlencoded
				//if(in_s.startsWith("Content-Type:") == true){
				//	spl_d = in_s.split(" ");
				//	if(spl_d.length>=1){
				//		content_type=spl_d[1];
				//	}
				//	System.out.println("content_type="+content_type);
				//	if(content_type.startsWith("multipart/form-data")==true){
				//		multipart_f=true;
				//		if(spl_d.length>=2){
				//			s=spl_d[2];
				//			boundary = s.substring(9);
				//			boundary1 = "--"+boundary;
				//			boundary2 = boundary1+"--";
				//		}
				//		System.out.println("boundary="+boundary+",length="+boundary.length());
				//		System.out.println("boundary1="+boundary1+",length="+boundary1.length());
				//		System.out.println("boundary2="+boundary2+",length="+boundary2.length());
				//	}
				//}
			}
			if(http_hd.get("Host:") != null){
				host=http_hd.get("Host:");
			}
			System.out.println("host="+host);
			s=http_hd.get("Content-Type:");
			if(s != null){
				if(s.startsWith("multipart/form-data")==true){
					multipart_f=true;
					spl_d = s.split(" ");
					if(spl_d.length>1){
						boundary = spl_d[1].substring(9);
						boundary1 = "--"+boundary;
						boundary2 = boundary1+"--";
						System.out.println("boundary="+boundary+",length="+boundary.length());
						System.out.println("boundary1="+boundary1+",length="+boundary1.length());
						System.out.println("boundary2="+boundary2+",length="+boundary2.length());
					}
				}
			}
			
			if(method.equals("POST")){
				System.out.println("HttpReader::read_din() :#4 read POST data start!");

				int n=0;
				ph=0;	// phase 
						// 0 -> non muliti
						// 1 -> boundary wait
						// 2 --> Content-Disposition wait
				//din_r.debug=true;
				// read POST data lines
				String p_name="";
				String p_filename="";
				String p_val="";
				String p_line="";
				if(multipart_f){
					ph=1;
				}
				while (din_r.ready() == true && n < 20000){
					p_line=din_r.readline();
					System.out.println("HttpReader::read_din() :#5 ph="+ph+",p_line="+p_line);
					switch(ph){
					case 0:	// non muliti part
						p_data+=p_line;
						break;
					case 1:	// muliti part waiting boundary
						if(p_line.equals(boundary1)==true){
							ph=2;
							System.out.println("HttpReader::read_din() :#6 boundary1 come >"+p_line);
						}
						else if(p_line.equals(boundary2)==true){
							System.out.println("HttpReader::read_din() :#7 boundary2 come >"+p_line);
						}
						break;
					case 2:	// muliti part waiting Content-Disposition:
						// Content-Disposition: form-data; name="tno"  --> ph=3
						// Content-Disposition: form-data; name="simg"; filename=""  --> ph=10
						if(p_line.startsWith("Content-Disposition:") == true){
							s=p_line.substring(p_line.indexOf("name=")+6);
							p_name=s.substring(0,s.indexOf("\""));
							System.out.println("HttpReader::read_din() :#8 p_name="+p_name);
							
							if(p_line.indexOf("filename=") >=0){
								s=p_line.substring(p_line.indexOf("filename=")+10);
								p_filename=s.substring(0,s.indexOf("\""));
								System.out.println("HttpReader::read_din() :#9 p_filename="+p_filename);
								if(p_data.length()==0){
									p_data+=p_name+"="+p_filename;
								}
								else{
									p_data+="&"+p_name+"="+p_filename;
								}
								// アップロードファイル名を伝達するためのパラメータ名を作成
								upload_parm_name=p_name+"_"+p_filename;
								System.out.println("HttpReader::read_din() :#10 upload_parm_name="+upload_parm_name);
								ph=10;
							}
							else{
								ph=3;
							}
						}
						break;
					case 3:	// muliti part pass one line
						ph=4;
						break;
					case 4:	// muliti part get value
						p_val=p_line;
						if(p_data.length()==0){
							p_data+=p_name+"="+p_val;
						}
						else{
							p_data+="&"+p_name+"="+p_val;
						}
						ph=1;
						break;
					case 10:	// waiting for "Content-Type: application/octet-stream" line -> ph=11
								// waiting for "Content-Type: text/plain" line -> ph=11
								// or
								// waiting for "Content-Type: image/gif" line -> ph=12
								// waiting for "Content-Type: image/jpg" line -> ph=12
						System.out.println("HttpReader::read_din() :#11 ph="+ph+",p_line="+p_line);
						if(p_line.indexOf("application/octet-stream") >=0){
							ph=11;
						}
						else if(p_line.indexOf("text/plain") >=0){
							ph=11;
						}
						else if(p_line.indexOf("image/") >=0){
							ph=12;
						}
						else if(p_line.equals(boundary1)==true || p_line.equals(boundary2)==true){
							ph=2;
						}
						break;
					case 11: // reading octet-stream , text/plain
						if(p_line.equals(boundary1)==true || p_line.equals(boundary2)==true){
							ph=2;
						}
						break;
					case 12: // image/xxx reading
						System.out.println("HttpReader::read_din() :#12 ph="+ph+",p_line="+p_line);
						// 1 brank line come
						if(p_line.length() == 0){
							System.out.println("HttpReader::read_din() :#13 passed !!");
							// img ファイル受け取り
							p_val=upload_img(din_r);
							if(p_data.length()==0){
								p_data+=upload_parm_name+"="+p_val;
							}
							else{
								p_data+="&"+upload_parm_name+"="+p_val;
							}
						}
						break;
					}
					n++;
				}
			}
		}
		catch(IOException e){
			System.out.println("HttpReader::read_din() :#90 error ="+e);
		}
	}
	/*
	 * img ファイルの受け取りを行います。
	 */
	private String upload_img(HttpDataInputStream din_r) throws IOException{
		boolean end_f=false;
		boolean boundary_f=false;
		int data_l=0;
		int j=0;
		int ptr;
		byte[] buff;
		String boundary_chk;
		String tmp_f=make_upload_fname();
		HttpReaderBuff data_bf = new HttpReaderBuff();
		
		File tmp_dir=new File(Defs.tmp_dir);
		if(tmp_dir.exists()==false){
			if(tmp_dir.mkdir()==false){
				System.out.println("HttpReader::upload_img() :#1 file upload dir="+Defs.tmp_dir+" alloc error");
			}
		}
		
		File tmp_file=new File(Defs.tmp_dir+"/"+tmp_f);
		OutputStream out = new FileOutputStream(tmp_file);
			
		//din_r.debug2=true;
		while(din_r.ready() == true && j < 10000 && end_f==false){	// reading img loop
			System.out.println("HttpReader::upload_img() :#2 j="+j);
			// 3この読み込みバッファーの空きバッファーを取得します。
			ptr=data_bf.getNext();	// get free buffer No.
			buff=data_bf.getBuff(ptr);
			// 上記バッファーにバイトデータを LF(0x0a)までとりあえず読み込みます。
			data_l=din_r.readData(buff,data_bf.getBuffLength());
			data_bf.setDataLength(ptr,data_l);
			System.out.println("HttpReader::upload_img() :#3 read data_l="+data_l+",ptr="+ptr);
			if(data_l <= 0){
				// 最後が、img の場合、もバウンダーリレコードがあります。
				// バウンダーリレコードがある場合は、0d+0a が在ると思うので、通常は、ここに来ません。
				// 必ず 1バイト以上は、読み込めると思います。
				end_f=true;
			}
			// バウンダリーと同じデータサイズであれば、boundary1,2 のチェックをします
			else if(data_l == boundary1.length()+2 || data_l == boundary2.length()+2){
				boundary_chk="";
				for(int i=0;i < data_l;i++){
					if(buff[i] != 0x0d && buff[i] != 0x0a){
						//boundary_chk+=Byte.toString(buff[i]);
						boundary_chk+=(char)buff[i];
					}
				}
				// boundary line です
				if(boundary1.equals(boundary_chk)==true || boundary2.equals(boundary_chk)==true){
					end_f=true;
					boundary_f=true;;
					data_bf.removeNew();	//remove  this boundary line
					System.out.println("HttpReader::upload_img() :#4 get boundary="+boundary_chk);
				}
				//System.out.println("HttpReader::upload_img() :#5 boundary_chk="+boundary_chk);
			}
			// imgデータの終了でなくて、バッファーが３個溜れば、一番古いバッファーをファイルに出力します。
			if(end_f==false){
				if(data_bf.remain >= 3){
					ptr=data_bf.getLast();
					buff=data_bf.getBuff(ptr);
					data_l=data_bf.getDataLength(ptr);
					if(data_l > 0){
						System.out.println("HttpReader::upload_img() :#6 write data ptr="+ptr+",data_l="+data_l);
						out.write(buff,0,data_l);
					}
				}
			}
			j++;
		}
		// バウンダリーで imgデータが終わった場合、バウンダリーレコードの前の,cr+lf が最後のimgデータに
		// くっついているので、その cf,lf を削除します。
		remove_crlf(data_bf);
		// 未出力のバッファーをファイルに出力します。
		for(int i=0;data_bf.remain >0 && i <3;i++){
			ptr=data_bf.getLast();
			buff=data_bf.getBuff(ptr);
			data_l=data_bf.getDataLength(ptr);
			if(data_l > 0){
				System.out.println("HttpReader::upload_img() :#7 write data ptr="+ptr+",data_l="+data_l);
				out.write(buff,0,data_l);
			}
		}
		out.close();
		tmp_file.setWritable(true,true);
		if(boundary_f==true){
			ph=2;
		}
		else{
			ph=1;
		}
		return tmp_f;
	}
	/*
	 * remove_crlf()
	 * img データのファイルへの未出力のバッファーから、最後のデータ部分に、
	 * cf,lf があれば取り除きます。
	 */
	private void remove_crlf(HttpReaderBuff data_bf){
		int ptr;
		byte[] buff;
		int data_l;
		// 1番新しいバッファーポインターを取得
		ptr=data_bf.getNew(0);
		if(ptr >= 0){
			buff=data_bf.getBuff(ptr);
			data_l=data_bf.getDataLength(ptr);
			if(data_l >= 2){
				// 最後が LF です
				if(buff[data_l-1]==0x0a){
					data_l--;
				}
				// 最後が CR です
				if(buff[data_l-1]==0x0d){
					data_l--;
				}
				data_bf.setDataLength(ptr,data_l);
			}
			// バッファには、1バイトのデータだけです。
			else if(data_l == 1){
				// 最後が LF です
				if(buff[data_l-1]==0x0a){
					data_l--;
				}
				data_bf.setDataLength(ptr,data_l);

				// 2個まえのバッファーのポインタを取得
				ptr=data_bf.getNew(-1);
				if(ptr >=0){
					buff=data_bf.getBuff(ptr);
					data_l=data_bf.getDataLength(ptr);
					if(data_l >= 1){
						// 最後が CR です
						if(buff[data_l-1]==0x0d){
							data_l--;
						}
						data_bf.setDataLength(ptr,data_l);
					}
				}
			}
		}
	}
	/*
	 * アップロードファイル用の tmp名称を作成します。
	 */
	private String make_upload_fname(){
		String temp_name;
		long currentTimeMillis = System.currentTimeMillis();
		Date date = new Date(currentTimeMillis);
		SimpleDateFormat simpleDateFormat = new SimpleDateFormat("ddHHmmss-SSS");
		temp_name="tmp-"+simpleDateFormat.format(date);
		return temp_name;
	}
}
